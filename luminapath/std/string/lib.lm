use std:ptr
use std:io
use std:list [List [Slice, Nil]]
use std:list:vec [Vec]

// NOTE: DO NOT SWITCH PLACES OF METHODS.
//
// THEIR INDICES ARE CONSTANTS IN COMPILER. 
pub trait Stringable
  fn split_at as self, uint -> (self, self)
  fn split_while as self, fn(u8 -> bool) -> (self, self)
  fn split_first as self -> (u8, self)
  fn equals as self, self -> bool
  fn from_raw_parts as *u8, uint -> self

// TODO: all these arguments should be flipped 
// so that they work with dot-pipe. 
impl Stringable for string
  fn split_at str i as string, uint -> (string, string) = 
    let (x, y) = str.inner . split_at i in
      ({ inner = x }, { inner = y })

  fn split_while str f as string, fn(u8 -> bool) -> (string, string) = 
    let (x, y) = str.inner . break #(\byte -> not (f byte)) in
      ({ inner = x }, { inner = y })

  fn split_first str as string -> (u8, string) = 
    match str.inner . split
    | Nothing -> (0, str)
    | Just (x, xs) -> (x, { inner = xs })

  fn equals lhs rhs as string, string -> bool = 
    do io:println (show (len lhs)) then
    do io:println (show (len rhs)) then
    do io:println ("checking if " <++> lhs <++> " equals " <++> rhs) then
    lhs == rhs

  fn from_raw_parts ptr len as *u8, uint -> string =
    if len == 0
      then { string | inner = List:Nil }
      else { string | inner = List:Slice ({ Vec u8 | ptr, len } . slice) }

pub type string {
  inner List u8
}

pub fn len {inner} as string -> uint = inner . len

pub fn toByteVec str as string -> Vec u8 =
  match str.inner
  | Slice {std:list:vec:Slice u8 | vec, start} -> vec
  | _ -> 
    let vec = vec:capacity (len str) in
      do str.inner
         . fold #(\i v -> do vec:unsafe_set i v vec then i + 1) 0
      then vec

pub fn to_c_str str as string -> *u8 =
  let vec = vec:capacity (1 + len str) in
      do str.inner
         . fold #(\i v -> do vec:unsafe_set i v vec then i + 1) 0
      then
      // TODO: just use a `list_to_vec` method
        do vec:unsafe_set vec.len 0 vec then vec.ptr

pub trait ToString
  fn show as self -> string

pub fn <> left right as string, string -> string =
  match left.inner
  | Nil -> right
  | _  -> { string | inner = List:Concat left.inner right.inner }

pub fn <:> left right as u8, string -> string =
  { string | inner = left : right.inner }

pub fn <++> left right as string, string -> string =
  { string | inner = left.inner ++ right.inner }

pub fn <+> left right as string, u8 -> string =
  { string | inner = left.inner ++ [right] }

pub fn contains_char c str as u8, string -> bool =
  str.inner . any #(\b -> b == c)

impl ToString for string
  fn show str = str

impl ToString for i64
  fn show n = 
    // TODO: we need to abs `n`
    let str = show (n as u64) in
      if n < 0
        then 45 <:> str
        else str

impl ToString for i32
  fn show n = ToString:show (n as i64)

impl ToString for u8
  fn show n = show (n as u64)

// TODO: This would be much more efficient if we manually used `Vec`.
// However; I think a better way to approach this is a more general MIR/LIR optimisation
// which detects and transforms this kind of code? Should be possible. 
//
// Since `string` has the same layout as `List` perhaps we could do it transparently post-monomorphisation?
impl ToString for u64
  fn show n =
    if n == 0 then "0" else showNext n
  where
    fn showNext n as u64 -> string =
      match n
      | 0 -> ""
      | _ ->
        let c = ((n % 10) as u8) + 48 in
           showNext (n / 10) <+> c

// TODO: we are gonna want `match` desugaring sugar for strings as well. 
//
// But I'm not sure how that'd look like. We could just use the List stuff but maybe we can be fancier? 
pub fn split_first str as string -> Maybe (u8, string) =
  str.inner . split
  . map #(\(c, xs) -> (c, { string | inner = xs }))


// TODO: Considder splitting equality out from Compare
// (Eq + Ordering)
//
// Since adding it for string is kinda stupid
//
// Trait aliases could be nice here
impl Compare for string
  fn == lhs rhs as self, self -> bool =
    lhs.inner == rhs.inner

  fn < lhs rhs as self, self -> bool = 
    lhs.inner < rhs.inner

  fn > lhs rhs as self, self -> bool =
    lhs.inner > rhs.inner

// pub fn lines str as string -> [string] =
//   split_on "\n" str
// 
// pub fn split_on c str as string, string -> [string] = 
//   str.inner . split_on c.inner
