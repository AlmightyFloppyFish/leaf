pub use std:math [Num [..], Compare [..]]
pub use std:maybe [Maybe [..]]
pub use std:string [string]
pub use std:nothing [nothing]
use std:ptr
use std:list [Listable [:], List]
use std:list:vec [Vec]

@![langItem(list as List)]

trait Closure p r
  fn call as self, p -> r

pub trait Size
  fn of as uint

// WARNING: Compiler assumes specific layout of `Type`
pub type Type
  = Int bool u8
  | Float
  | Bool
  | Never
  | Poison
  | Pointer   Type
  | FnPointer [Type] Type
  | Struct string [(string, Type)]
  | Sum    string [(string, [Type])]
  | Tuple  [Type]
  | Object string

// TODO: for this to be a valid declaration then we need the compiler to expose
// a more advancedf TypeId API instead. 
//
// Because; currently a reflect like this will lock up the compiler on recursive data structures
// since this API doesn't account for autoboxing. 
//
// We could of course *add* autoboxing but if we do; then we wouldn't be able to use this function for things like
// `Show`. So; let's park this for now and think about reflection API designs later. 
//
// impl Size for a
//   fn of as int = size_of_ty builtin:reflect_type(self as a)

impl Size for a
  fn of as uint = builtin:size_of(self as a)

// WARNING: Compiler assumes specific layout of `string_from_raw_parts`
fn string_from_raw_parts ptr len as *u8, uint -> string =
  { string | inner = List:Slice ({ std:list:vec:Vec u8 | ptr, len } . slice) }

// fn size_of_ty ty as Type -> int =
//     match ty
//     | Int _ size -> (size as int) / 8
//     | Float  -> 8
//     | Bool   -> 1
//     | Never  -> 0
//     | Poison -> 0
//     | Pointer _ -> 8
//     | FnPointer _ _ -> 8
//     | Struct _ fields   -> fields . map #(\_ ty -> size_of_ty ty) . sum
//     | Sum    _ variants -> tag_size + variants . map #(\_ params -> list:map #size_of_ty params . sum) . max . or #0
//     | Tuple fields -> fields . map #(\_ ty -> size_of_ty ty) . sum
//     | Object _ -> 16
//  where
//   fn tag_size = 4

@[platform "linux"]
fn alloc size as int -> *u8 =
  mmtk_alloc main_thread_mutator size 8 0 0

@[platform "linux"]
fn dealloc ptr size as *u8, int -> () = free ptr

@[extern "free", platform "linux"]
fn free as *u8 -> ()

@[extern "x86_64_syscall", platform "linux"]
fn syscall as int, int, int, int, int, int -> ()

@[platform "x86_64-linux"]
fn raw_syscall_exit code as int -> () =
  do syscall code 0 0 0 0 60 then ()

@[platform "linux"]
pub fn exit code as int -> () =
  libc_exit code

@[extern "exit", platform "linux"]
fn libc_exit code as int -> ()

@[extern "mmtk_init", platform "linux"]
fn lumina_gc_init as uint -> ()

@[extern "mmtk_bind_mutator", platform "linux"]
fn mmtk_bind_mutator as *u8 -> *u8

@[extern "mmtk_alloc", platform "linux"]
fn mmtk_alloc mutator size align offset allocator
  as *u8, int, int, int, int -> *u8

// TODO: To support multi-threadding we'd need thread local storage
// then initialise MMTK seperately from creating the mutator
// then create a mutator for each thread
val main_thread_mutator as *u8 = 
  do lumina_gc_init 1048576 then
     let mutator = mmtk_bind_mutator ptr:null in mutator
       // do mmtk_initialize_collection mutator then mutator

@[extern "mmtk_initialize_collection", platform "linux"]
fn mmtk_initialize_collection as *u8 -> ()
