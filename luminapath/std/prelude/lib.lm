pub use std:math [Num [..], Compare [..]]
pub use std:maybe [Maybe [..]]
pub use std:result [Result [..]]
pub use std:string [string, ToString [show], <:>, <++>, <+>]
pub use std:list [Listable [:], List, ++]
use std:string [Stringable]
pub use std:nothing [nothing]
use std:ptr
use std:list:vec [Vec]
use std:gc
use std:env [process_arguments]

// we need these so that their implementations are always included
use std:tuple
use std:bool

@![langItem(list as List)]

trait Closure p r
  fn call as self, p -> r

pub trait Size
  fn of as uint

// WARNING: Compiler assumes specific layout of `Type`
pub type Type
  = Int bool u8
  | Float
  | Bool
  | Never
  | Poison
  | Pointer   Type
  | FnPointer [Type] Type
  | Struct string [(string, Type)]
  | Sum    string [(string, [Type])]
  | Tuple  [Type]
  | Object string

// TODO: for this to be a valid declaration then we need the compiler to expose
// a more advancedf TypeId API instead. 
//
// Because; currently a reflect like this will lock up the compiler on recursive data structures
// since this API doesn't account for autoboxing. 
//
// We could of course *add* autoboxing but if we do; then we wouldn't be able to use this function for things like
// `Show`. So; let's park this for now and think about reflection API designs later. 
//
// impl Size for a
//   fn of as int = size_of_ty builtin:reflect_type(self as a)

impl Size for a
  fn of as uint = builtin:size_of(self as a)

// fn size_of_ty ty as Type -> int =
//     match ty
//     | Int _ size -> (size as int) / 8
//     | Float  -> 8
//     | Bool   -> 1
//     | Never  -> 0
//     | Poison -> 0
//     | Pointer _ -> 8
//     | FnPointer _ _ -> 8
//     | Struct _ fields   -> fields . map #(\_ ty -> size_of_ty ty) . sum
//     | Sum    _ variants -> tag_size + variants . map #(\_ params -> list:map #size_of_ty params . sum) . max . or #0
//     | Tuple fields -> fields . map #(\_ ty -> size_of_ty ty) . sum
//     | Object _ -> 16
//  where
//   fn tag_size = 4

@[platform ["linux-gnu", "linux-musl"]]
fn alloc size as int -> *u8 = std:gc:alloc size

@[platform ["linux-gnu", "linux-musl"]]
fn dealloc ptr size as *u8, int -> () = std:gc:free ptr

@[extern "x86_64_syscall", platform "linux"]
fn syscall as int, int, int, int, int, int -> ()

@[no_mangle, platform ["linux-gnu", "linux-musl"]]
fn _lumina_sys_init argc argv as i32, **u8 -> () = 
  let args = vec:from_range (0, argc as uint) #(\i -> vec:bytes_from_null_terminated (ptr:offsetu argv (i * 8) . ptr:deref))
    in ptr:write (builtin:val_to_ref process_arguments) args

pub fn not b as bool -> bool =
  if b then false else true
