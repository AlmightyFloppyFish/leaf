use std:ptr 
use std:list [Listable]
use std:math [Compare [>=]]

// An immutable heap-allocated array
pub type Vec a {
  ptr *a
  len uint
}

pub fn capacity len as uint -> Vec a =
  let ptr = std:prelude:alloc ((Size(a):of * len) as int)
   in { ptr = ptr as *a, len }

pub fn empty as Vec a = { Vec a | ptr = ptr:null, len = 0 }

pub fn singleton v as a -> Vec a = 
  { ptr = ptr:box v, len = 1 }

pub fn slice vec as Vec a -> Slice a =
  { vec, start = 0 }

pub fn get i vec as uint, Vec a -> Maybe a =
  if i >= vec.len
    then Nothing
    else Just (unsafe_get i vec)

fn unsafe_get i {ptr, len} as uint, Vec a -> a =
  ptr:offset ptr (i as int) . ptr:deref

fn unsafe_set i v {ptr, len} as uint, a, Vec a -> () =
   let at = ptr:offset ptr (i as int) in
    ptr:write at v

pub type Slice a {
  vec   Vec a
  start uint
}

pub fn split {vec, start} as Slice a -> Maybe (a, Slice a) =
  get start vec
  . map #(\v -> (v, {Slice a | vec, start = start + 1}))

pub fn forEach f slice as fn(a -> ()), Slice a -> () =
  list:itimes #perform (slice.vec.len - slice.start)
 where
  fn perform i as uint -> () = ptr:offset slice.vec.ptr ((slice.start + i) as int) . ptr:deref . f

pub fn map f slice as fn(a -> b), Slice a -> Vec b =
  let vec = capacity(a as b) (slice.vec.len - slice.start) in
    from_range
      (slice.start, slice.vec.len)
      #(\i -> unsafe_get i slice.vec . f)
    // list:itimes #perform (slice.vec.len - slice.start)

pub fn from_range (start, end) f as (uint, uint), fn(uint -> a) -> Vec a =
  // TODO: bound checks
  let count = (end - start) in
  let vec = capacity count in
    do list:itimes #(\i -> unsafe_set i (f (i + start)) vec) count
    then vec

fn bytes_from_null_terminated ptr as *u8 -> Vec u8 =
  findZero 0
 where
  fn findZero i as uint -> Vec u8 = 
    if ptr:deref (ptr:offsetu ptr i) == 0
      then { ptr, len = i }
      else findZero (i + 1)
