//! Optimizations that are more specific to Lumina and more appropriate for a higher-level IR than
//! our backends.

use crate::lir::{
    ssa, ty_fmt, Block, ControlFlow, Entry, Function, MonoFunc, Output, Value, LIR, V,
};
use lumina_collections::{Map, MapKey};
use tracing::{error, info, info_span, warn};

impl LIR {
    pub fn perform_optimizations(&mut self) {
        let mut opt = Optimizer { lir: self };
        opt.const_fold();
    }
}

struct Optimizer<'a> {
    // meta: Map<MonoFunc, FuncMetadata>,
    lir: &'a mut LIR,
}

impl<'a> Optimizer<'a> {
    fn const_fold(&mut self) {
        // I think it's smarter to just apply all our high-level optimizations in a single sweep?
        //
        // We should probably set and update function meta-data as we go during LIR lower.
        //
        // OR: we take the opposite route. We make it so that when performing optimizations we
        // don't seek information at any depth but instead just repeat optimizations. I think
        // that's how people 'normally' do it?

        for fkey in self.lir.functions.keys() {
            let _span = info_span!(
                "running LIR optimizer",
                entity = self.lir.functions[fkey].symbol,
                key = fkey.to_string(),
            );
            let _handle = _span.enter();

            error!(
                "{}",
                ty_fmt(&self.lir.mono.types, &self.lir.functions[fkey])
            );

            'block_iter: for block in self.lir.functions[fkey].blocks.blocks() {
                info!("entering {block}");
                for v in self.lir.functions[fkey].blocks.entries(block) {
                    let entry = self.lir.functions[fkey].blocks.entry_of(v);

                    info!("optimizing {v} = {entry}");

                    match entry {
                        Entry::CallStatic(mfunc, params) => {
                            if self.should_inline(*mfunc) {
                                let params = params.clone();
                                let [fin, ftarget] =
                                    self.lir.functions.get_many_mut([fkey, *mfunc]);
                                Optimizer::inline_function(ftarget, fin, block, v, params);
                                break 'block_iter;
                            }
                        }
                        // Entry::Construct(_) => todo!(),
                        // Entry::Replicate(_, _) => todo!(),
                        // Entry::Variant(_, _) => todo!(),
                        // Entry::IntAdd(_, _) => todo!(),
                        // Entry::IntSub(_, _) => todo!(),
                        // Entry::IntMul(_, _) => todo!(),
                        // Entry::IntDiv(_, _) => todo!(),
                        // Entry::IntAbs(_) => todo!(),
                        // Entry::IntToFloat(_, _) => todo!(),
                        // Entry::FloatToInt(_, _) => todo!(),
                        // Entry::BitAnd(_) => todo!(),
                        // Entry::BitNot(_) => todo!(),
                        // Entry::BlockParam(_) => todo!(),
                        _ => {}
                    }
                }
            }

            warn!(
                "{}",
                ty_fmt(&self.lir.mono.types, &self.lir.functions[fkey])
            );
        }
    }

    fn should_inline(&self, f: MonoFunc) -> bool {
        let func = &self.lir.functions[f];
        !func.directly_recursive && (func.invocations == 1 || self.inlineable(f))
    }

    fn inlineable(&self, f: MonoFunc) -> bool {
        self.lir.functions[f].blocks.entries_count() < 5
    }

    fn inline_function(
        ftarget: &Function,
        fin: &mut Function,
        inbl: Block,
        at: V,
        params: Vec<Value>,
    ) {
        // Merge the values of the target function into this one inbetween `v` and `v+1`
        merge_at(at, &mut fin.blocks.vtypes, &ftarget.blocks.vtypes);
        merge_at(at, &mut fin.blocks.ventries, &ftarget.blocks.ventries);

        // Inline the blocks (raw with incorrect value indexes)
        let inlined_entry_block = fin.blocks.blocks.next_key();
        fin.blocks
            .blocks
            .as_mut_vec()
            .extend_from_slice(ftarget.blocks.blocks.as_slice());

        let inbl_offset = fin.blocks.blocks[inbl].offset.unwrap();
        let moved_values = inbl_offset.1 .0 - at.0;
        let added_values = ftarget.blocks.vtypes.len() as u32;

        // The continuation block that will be jumped to instead of `return` from the inlined blocks
        let continuation = fin.blocks.blocks.push(ssa::BasicBlock::new(1));

        // Substitute the function call for a block jump to the inlined entry block
        let mut old_tail = std::mem::replace(
            &mut fin.blocks.blocks[inbl].tail,
            ControlFlow::JmpBlock(inlined_entry_block, params),
        );
        fin.blocks.blocks[inlined_entry_block].predecessors += 1;
        offset_flow(&mut old_tail, inlined_entry_block.0 + 1, at.0 + 1);
        fin.blocks.blocks[continuation].tail = old_tail;

        // Change the current blocks offset to stop at the current value
        // (since we want to move the following values to the continuation block)
        fin.blocks.blocks[inbl].offset.as_mut().unwrap().1 .0 -= moved_values;

        for block in (inbl.0 + 1..inlined_entry_block.0).map(Block) {
            if let Some(offset) = fin.blocks.blocks[block].offset.as_mut() {
                offset.0 .0 += added_values;
                offset.1 .0 += added_values;
            }
        }
        fin.blocks.blocks[continuation].offset = Some((
            V(at.0 + added_values),
            V(at.0 + moved_values + added_values),
        ));

        // YOU KNOW WHAT?
        //
        // I suspect: it'd be smarter to take everything we've learned.
        // make notes of everything
        //
        // and then create a new implementation of this from scratch.
        // this one is now too bloated and confusing.

        // Bump the block offsets to start at current instead of 0.
        // Bump the block id's of control flows to start at current instead of 0.
        for block in fin.blocks.blocks() {
            // Get the block in the current function which corresponds to the block in the function
            // we inlined.
            // let block = Block(block.0 + inlined_entry_block.0);

            if let Some(offset) = fin.blocks.blocks[block].offset.as_mut() {
                // Don't offset anything in this function if it occurs before the inline
                if offset.0 .0 < at.0 {
                    continue;
                }

                offset.0 .0 += at.0 + 1;
                offset.1 .0 += at.0 + 1;
            }

            for v in fin.blocks.entries(block) {
                fin.blocks.ventries[v].for_values_mut(|ov| offset_value(ov, at.0 + 1));
            }

            let tail = &mut fin.blocks.blocks[block].tail;
            let boffset = inlined_entry_block.0 + 1;
            let voffset = at.0 + 1;
            offset_flow(tail, boffset, voffset);
            if let ControlFlow::Return(v) = tail {
                let v = *v;
                fin.blocks.blocks[continuation].predecessors += 1;
                fin.blocks.blocks[block].tail = ControlFlow::JmpBlock(continuation, vec![v]);
            }

            // match &mut fin.blocks.blocks[block].tail {
            //     ControlFlow::JmpBlock(block, params) => {
            //         offset_values(params, at.0 + 1);
            //         block.0 += inlined_entry_block.0
            //     }
            //     ControlFlow::Select { on_true, on_false, value } => {
            //         offset_value(value, at.0 + 1);
            //         on_true.0 .0 += inlined_entry_block.0 + 1;
            //         on_false.0 .0 += inlined_entry_block.0 + 1;
            //     }
            //     ControlFlow::JmpTable(v, params, blocks) => {
            //         offset_value(v, at.0 + 1);
            //         offset_values(params, at.0 + 1);
            //         blocks
            //             .iter_mut()
            //             .for_each(|block| block.0 += inlined_entry_block.0)
            //     }
            //     ControlFlow::JmpFunc(_, params) => {
            //         offset_values(params, at.0 + 1);
            //     }
            //     // TODO: we actually want to replace this with continuation
            //     ControlFlow::Return(v) => {
            //         offset_value(v, at.0 + 1);
            //         let v = *v;
            //         fin.blocks.blocks[continuation].predecessors += 1;
            //         fin.blocks.blocks[block].tail = ControlFlow::JmpBlock(continuation, vec![v]);
            //     }
            //     _ => {}
            // }
        }
    }
}

fn offset_flow(flow: &mut ControlFlow, boffset: u32, voffset: u32) {
    match flow {
        ControlFlow::JmpBlock(block, params) => {
            offset_values(params, voffset);
            block.0 += boffset;
        }
        ControlFlow::Select { on_true, on_false, value } => {
            offset_value(value, voffset);
            on_true.0 .0 += boffset;
            on_false.0 .0 += boffset;
        }
        ControlFlow::JmpTable(v, params, blocks) => {
            offset_value(v, voffset);
            offset_values(params, voffset);
            blocks.iter_mut().for_each(|block| block.0 += boffset)
        }
        ControlFlow::JmpFunc(_, params) => {
            offset_values(params, voffset);
        }
        // TODO: we actually want to replace this with continuation
        ControlFlow::Return(v) => {
            offset_value(v, voffset);
        }
        _ => {}
    }
}

fn offset_value(value: &mut Value, by: u32) {
    match value {
        Value::V(ov) => ov.0 += by,
        _ => {}
    }
}

fn offset_values(values: &mut [Value], by: u32) {
    values.iter_mut().for_each(|v| offset_value(v, by))
}

fn merge_at<K: MapKey, V: Clone>(k: K, map: &mut Map<K, V>, added: &Map<K, V>) {
    let after = split_and_insert(k, map, added);
    map.as_mut_vec().extend(after);
}

// Inserts `added` at `k` so that `k` remains but all keys after it are returned and replaced by `added`
fn split_and_insert<K: MapKey, V: Clone>(k: K, map: &mut Map<K, V>, added: &Map<K, V>) -> Vec<V> {
    let after = map.as_mut_vec().split_off(k.into() + 1);
    map.as_mut_vec().extend_from_slice(added.as_slice());
    after
    // map.as_mut_vec().extend(after);
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::lir::{MonoFormatter, MonoType};
    use lumina_typesystem::IntSize;

    // fn main =
    //   let five = 5 in
    //     if five
    //       then inner five 10
    //       else do 0 then 200
    //
    // fn inner a b =
    //   let x = 8 in
    //   let v = x + 2 in
    //     if v
    //       then (do 0 then b) // these `b` and `a` should be the `v`s in the params
    //       else (do 0 then a)

    fn outer(innerf: MonoFunc) -> (ssa::Blocks, V, Vec<Value>) {
        let mut ssa = ssa::Blocks::new(0);
        let uint = IntSize::new(false, 64);

        let five = ssa.copy(Value::Int(5, uint), MonoType::Int(uint));

        let [truthy, falsely] = [(); 2].map(|_| ssa.new_block(0));
        ssa.select(five, [(truthy, vec![]), (falsely, vec![])]);

        ssa.switch_to_block(truthy);
        let ten = ssa.copy(Value::Int(10, uint), MonoType::Int(uint));
        let v = ssa.call(innerf, vec![five, ten], MonoType::Int(uint));
        let combined = ssa.add(v, five, MonoType::Int(uint));
        ssa.return_(combined);

        ssa.switch_to_block(falsely);
        ssa.copy(Value::Int(0, uint), MonoType::Int(uint));
        ssa.return_(Value::Int(200, uint));

        let Value::V(v) = v else { unreachable!() };
        (ssa, v, vec![five, ten])
    }

    fn inner() -> ssa::Blocks {
        let mut ssa = ssa::Blocks::new(2);
        let uint = IntSize::new(false, 64);

        let params = [(); 2].map(|_| ssa.add_block_param(Block::entry(), MonoType::Int(uint)));

        let n = ssa.copy(Value::Int(8, uint), MonoType::Int(uint));
        let n = ssa.add(n, Value::Int(2, uint), MonoType::Int(uint));

        let [truthy, falsely] = [(); 2].map(|_| ssa.new_block(0));
        ssa.select(n, [(truthy, vec![]), (falsely, vec![])]);

        ssa.switch_to_block(truthy);
        ssa.copy(Value::Int(0, uint), MonoType::Int(uint));
        ssa.return_(params[1].value());

        ssa.switch_to_block(falsely);
        ssa.copy(Value::Int(0, uint), MonoType::Int(uint));
        ssa.return_(params[0].value());

        ssa
    }

    #[test]
    fn inlining() -> () {
        let uint = IntSize::new(false, 64);
        let inner = inner();
        let (outer, call, params) = outer(MonoFunc(1));

        let mut outerf = Function::new("outer".into(), outer, MonoType::Int(uint), 1);
        let mut innerf = Function::new("inner".into(), inner, MonoType::Int(uint), 1);

        fn tfmt<'a>(v: &Function) -> MonoFormatter<'a, &Function> {
            let types = Box::leak(Box::new(Map::new()));
            MonoFormatter { types, v }
        }

        // TODO: TODO: It crashes if we don't have any bindings in the block since then there
        // aren't any offsets.
        //
        // We need an unwrap_or or something

        println!(
            "before optimizations:\n{}\n\n{}",
            tfmt(&outerf),
            tfmt(&innerf)
        );

        Optimizer::inline_function(&mut innerf, &mut outerf, Block(1), call, params);

        println!(" --------------------- ");

        println!("after optimizations:\n{}", tfmt(&outerf),);

        panic!("OK");
    }
}
