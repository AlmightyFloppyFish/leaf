//! Optimizations that are more specific to Lumina and more appropriate for a higher-level IR than
//! our backends.

use crate::lir::{
    mono::Types, ssa, ty_fmt, Block, ControlFlow, Entry, Function, MonoFunc, Output, Value, LIR, V,
};
use itertools::Itertools;
use lumina_collections::{Map, MapKey};
use tracing::{error, info, info_span, warn};

impl LIR {
    pub fn perform_optimizations(&mut self) {
        let mut opt = Optimizer { lir: self };
        opt.const_fold();
    }
}

struct Optimizer<'a> {
    // meta: Map<MonoFunc, FuncMetadata>,
    lir: &'a mut LIR,
}

impl<'a> Optimizer<'a> {
    fn const_fold(&mut self) {
        // I think it's smarter to just apply all our high-level optimizations in a single sweep?
        //
        // We should probably set and update function meta-data as we go during LIR lower.
        //
        // OR: we take the opposite route. We make it so that when performing optimizations we
        // don't seek information at any depth but instead just repeat optimizations. I think
        // that's how people 'normally' do it?

        for fkey in self.lir.functions.keys() {
            let _span = info_span!(
                "running LIR optimizer",
                entity = self.lir.functions[fkey].symbol,
                key = fkey.to_string(),
            );
            let _handle = _span.enter();

            error!(
                "{}",
                ty_fmt(&self.lir.mono.types, &self.lir.functions[fkey])
            );

            'block_iter: for block in self.lir.functions[fkey].blocks.blocks() {
                info!("entering {block}");
                for v in self.lir.functions[fkey].blocks.entries(block) {
                    let entry = self.lir.functions[fkey].blocks.entry_of(v);

                    info!("optimizing {v} = {entry}");

                    match entry {
                        Entry::CallStatic(mfunc, params) => {
                            if self.should_inline(*mfunc) {
                                let params = params.clone();
                                let [fin, ftarget] =
                                    self.lir.functions.get_many_mut([fkey, *mfunc]);
                                let types = &self.lir.mono.types;
                                Optimizer::inline_function(types, ftarget, fin, block, v, params);
                                break 'block_iter;
                            }
                        }
                        // Entry::Construct(_) => todo!(),
                        // Entry::Replicate(_, _) => todo!(),
                        // Entry::Variant(_, _) => todo!(),
                        // Entry::IntAdd(_, _) => todo!(),
                        // Entry::IntSub(_, _) => todo!(),
                        // Entry::IntMul(_, _) => todo!(),
                        // Entry::IntDiv(_, _) => todo!(),
                        // Entry::IntAbs(_) => todo!(),
                        // Entry::IntToFloat(_, _) => todo!(),
                        // Entry::FloatToInt(_, _) => todo!(),
                        // Entry::BitAnd(_) => todo!(),
                        // Entry::BitNot(_) => todo!(),
                        // Entry::BlockParam(_) => todo!(),
                        _ => {}
                    }
                }
            }

            warn!(
                "{}",
                ty_fmt(&self.lir.mono.types, &self.lir.functions[fkey])
            );
        }
    }

    fn should_inline(&self, f: MonoFunc) -> bool {
        let func = &self.lir.functions[f];
        !func.directly_recursive && (func.invocations == 1 || self.inlineable(f))
    }

    fn inlineable(&self, f: MonoFunc) -> bool {
        self.lir.functions[f].blocks.entries_count() < 5
    }

    fn inline_function(
        types: &Types,
        ftarget: &Function,
        fin: &mut Function,
        inbl: Block,
        at: V,
        params: Vec<Value>,
    ) {
        let added_values = ftarget.blocks.ventries.len() as u32;
        let original_offset = fin.blocks.blocks[inbl].offset.unwrap();
        let original_block_len = fin.blocks.blocks.len() as u32;
        let remaining = (original_offset.1 - at.0).0 - 1;
        let added_blocks = ftarget.blocks.blocks.len() as u32;

        // Merge the values of the target function into this one inbetween `v` and `v+1`
        {
            let (after, call_bind_type) =
                split_and_insert(at, &mut fin.blocks.vtypes, &ftarget.blocks.vtypes);

            // continuation parameter is moved to after inlined values
            fin.blocks.vtypes.push(call_bind_type);
            fin.blocks.vtypes.as_mut_vec().extend(after);

            let (mut after, _call_bind) =
                split_and_insert(at, &mut fin.blocks.ventries, &ftarget.blocks.ventries);

            // Offset all references to values that are declared after the inline
            for entry in &mut after {
                entry.for_values_mut(|v| offset_value(at, v, added_values as u32));
            }

            // instead of the call_bind, this spot is now the continuation parameter
            fin.blocks
                .ventries
                .as_mut_vec()
                .push(Entry::BlockParam(V(0)));
            fin.blocks.ventries.as_mut_vec().extend(after);

            // Offset the flows for all pre-existing blocks
            // for block in fin.blocks.blocks() {
            //     let flow = &mut fin.blocks.blocks[block].tail;
            //     // TODO: TODO: It's difficult to figure out whether this block occurs before or after inline
            //     // because it might not even have any bindings. Which means offset will be empty.
            //     // But in those cases it can still have values in the flow.
            //     //
            //     // Maybe having `Option` for offsets is a bad idea?
            //     //
            //     // INFACT: we probably want to remove the `BlockParam` thing?
            //     // ALTHOUGH: something has to take up the ventry spot.
            //     //
            //     // MAYBE: we don't need to know that. We can just iter all of them and check
            //     // wherther it's created than some requirement?
            //     //
            //     // well ye, we need to check whether *the block we mutate* existed before.
            //     offset_flow(at, flow, added_blocks, added_values);
            // }
        }

        // At this point; due to the merge of values all the offsets are wrong.
        //
        // To correct them; all original code *after* the inline need to be offset by the amount of
        // values that were inlined.
        //
        // All values that are inserted from the inline need to be offset by the position of which
        // the inline started. So the entry blocks first parameter of the inlined function will
        // start at `at`

        // Create a new block which the inlined function will jump to as a continuation
        let continuation = {
            let block = fin.blocks.new_block(1);
            println!("created continuation {block}");

            // Set the block to cover the entries starting at the value after the inlined function.
            // Minus one because a value has been converted into a block parameter.
            let cstart = at + added_values as u32;
            let cend = cstart + remaining + 1;
            fin.blocks.blocks[block].offset = Some((cstart, cend));

            block
        };

        let blocks_that_arent_inline = (0..fin.blocks.blocks.len() as u32).map(Block);
        for block in blocks_that_arent_inline.clone() {
            dbg!(block);
            if let Some((start, end)) = fin.blocks.blocks[block].offset.as_mut() {
                // OK this breaks everything.
                //
                // with the other one, it appears that most of them do work.
                // start.0 += added_values;
                // end.0 += added_values;
                // todo!("I think we need to bump this?");
            }
            // let flow = &mut fin.blocks.blocks[block].tail;
            // todo!("we want to offset the blocks");
            // BUT WAIT: since we haven't merged blocks yet, doesn't that mean *all* blocks we
            // encounter here shouldn't be offset?
            //
            // NO: the things in the *continuation* need to be offset. But; everything *except* the
            // coninuation shouldn't need to be changed.
            //
            // SO: we only need to offset blocks in the added blocks and in the continuation?
        }

        // Copy the raw blocks from the target function into the current function.
        let inlined_entry = {
            let entry = fin.blocks.blocks.next_key();

            for block in ftarget.blocks.blocks.keys() {
                let mut blockdata = ftarget.blocks.blocks[block].clone();

                if let Some((start, end)) = blockdata.offset.as_mut() {
                    let old = (*start, *end);

                    start.0 += at.0;
                    end.0 += at.0;

                    println!("mapped {old:?} to {:?}", (*start, *end));

                    for v in (start.0..end.0).map(V) {
                        fin.blocks.ventries[v].for_values_mut(|v| offset_value(V(0), v, at.0 + 0));
                    }
                }

                // Instead of returning; jump to the continuation which has the code placed after
                // the function call we are inlining.
                //
                // The block parameter to the continuation corresponds to the lhs of the `v = call ...`
                offset_flow(V(0), &mut blockdata.tail, original_block_len + 1, at.0);
                if let ControlFlow::Return(v) = &mut blockdata.tail {
                    blockdata.tail = ControlFlow::JmpBlock(continuation, vec![*v]);
                }

                fin.blocks.blocks.push(blockdata);
            }

            entry
        };

        // Adjust the original block to jump to the inlined entry block.
        {
            let offset = fin.blocks.blocks[inbl].offset.as_mut().unwrap();
            offset.1 = at;

            let jump_to_inlined_entry = ControlFlow::JmpBlock(inlined_entry, params);

            let old_tail =
                std::mem::replace(&mut fin.blocks.blocks[inbl].tail, jump_to_inlined_entry);

            // Set the tail of the continuation to be what the tail of the original block was.
            fin.blocks.blocks[continuation].tail = old_tail;
        };

        // TODO: CURRENT ISSUE:
        //
        // Even though the IR looks 100% correct, there's still bad parameter starts..

        for block in fin.blocks.blocks() {
            // for v in fin.blocks.entries(block) {
            //     match fin.blocks.entry_of(v) {
            //         e @ Entry::BlockParam(_) => {
            //             panic!("{e}")
            //         }
            //         _ => {}
            //     }
            // }

            if let Some((start, _)) = fin.blocks.blocks[block].offset {
                let params = fin.blocks.blocks[block].parameters;
                dbg!(&block, &start, &params);
                for i in start.0..start.0 + params {
                    println!("{}", V(i));
                    match &fin.blocks.ventries[V(i)] {
                        Entry::BlockParam(_) => {}
                        other => {
                            println!("{}", ty_fmt(types, &fin.blocks));
                            println!("{}", &fin.blocks.ventries);
                            panic!("unexpected: {other}")
                        }
                    }
                }
            }
        }
    }
}

fn offset_flow(at: V, flow: &mut ControlFlow, boffset: u32, voffset: u32) {
    match flow {
        ControlFlow::JmpBlock(block, params) => {
            offset_values(at, params, voffset);
            block.0 += boffset;
        }
        ControlFlow::Select { on_true, on_false, value } => {
            offset_value(at, value, voffset);
            on_true.0 .0 += boffset;
            on_false.0 .0 += boffset;
        }
        ControlFlow::JmpTable(v, params, blocks) => {
            offset_value(at, v, voffset);
            offset_values(at, params, voffset);
            blocks.iter_mut().for_each(|block| block.0 += boffset)
        }
        ControlFlow::JmpFunc(_, params) => {
            offset_values(at, params, voffset);
        }
        // TODO: we actually want to replace this with continuation
        ControlFlow::Return(v) => {
            offset_value(at, v, voffset);
        }
        _ => {}
    }
}

fn offset_value(at: V, value: &mut Value, by: u32) {
    match value {
        Value::V(ov) if ov.0 >= at.0 => ov.0 += by,
        _ => {}
    }
}

fn offset_values(at: V, values: &mut [Value], by: u32) {
    values.iter_mut().for_each(|v| offset_value(at, v, by))
}

// fn merge_at<K: MapKey, V: Clone + std::fmt::Debug>(
//     k: K,
//     map: &mut Map<K, V>,
//     added: &Map<K, V>,
//     inbetween: Option<V>,
// ) {
//     let (after, removed) = split_and_insert(k, map, added);
//     let buf = map.as_mut_vec();
//     match inbetween {
//         Some(v) => buf.push(v),
//         None => buf.push(removed),
//     }
//     buf.extend(after);
// }

// Inserts `added` at `k` so that `k` remains but all keys after it are returned and replaced by `added`
fn split_and_insert<K: MapKey, V: Clone + std::fmt::Debug>(
    k: K,
    map: &mut Map<K, V>,
    added: &Map<K, V>,
) -> (Vec<V>, V) {
    let map = map.as_mut_vec();
    let after = map.split_off(k.into() + 1);

    // Remove the call instruction that we're inlining
    let removed = map.pop().unwrap();

    map.extend_from_slice(added.as_slice());
    (after, removed)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::lir::{MonoFormatter, MonoType};
    use lumina_typesystem::IntSize;

    fn outer(innerf: MonoFunc) -> (ssa::Blocks, V, Vec<Value>) {
        let mut ssa = ssa::Blocks::new(0);
        let uint = IntSize::new(false, 64);

        let five = ssa.copy(Value::Int(5, uint), MonoType::Int(uint));

        let [truthy, falsely] = [(); 2].map(|_| ssa.new_block(0));
        ssa.select(five, [(truthy, vec![]), (falsely, vec![])]);

        ssa.switch_to_block(truthy);
        let _ = ssa.copy(Value::Int(1, uint), MonoType::Int(uint));
        let _ = ssa.copy(Value::Int(2, uint), MonoType::Int(uint));
        let _ = ssa.copy(Value::Int(3, uint), MonoType::Int(uint));
        let _ = ssa.copy(Value::Int(4, uint), MonoType::Int(uint));
        let _ = ssa.copy(Value::Int(5, uint), MonoType::Int(uint));
        let ten = ssa.copy(Value::Int(6, uint), MonoType::Int(uint));
        let v = ssa.call(innerf, vec![five, ten], MonoType::Int(uint));
        let combined = ssa.add(v, five, MonoType::Int(uint));
        let _ = ssa.copy(Value::Int(7, uint), MonoType::Int(uint));
        let _ = ssa.copy(Value::Int(8, uint), MonoType::Int(uint));
        let _ = ssa.copy(Value::Int(9, uint), MonoType::Int(uint));
        let _ = ssa.copy(Value::Int(10, uint), MonoType::Int(uint));
        let _ = ssa.copy(Value::Int(11, uint), MonoType::Int(uint));
        let _ = ssa.copy(Value::Int(12, uint), MonoType::Int(uint));
        let _ = ssa.copy(Value::Int(13, uint), MonoType::Int(uint));

        let last_block = ssa.new_block(1);
        let rparam = ssa.add_block_param(last_block, MonoType::Int(uint));
        ssa.jump(last_block, vec![combined]);

        ssa.switch_to_block(last_block);
        ssa.return_(rparam.value());

        ssa.switch_to_block(falsely);
        ssa.copy(Value::Int(0, uint), MonoType::Int(uint));
        ssa.return_(Value::Int(200, uint));

        let Value::V(v) = v else { unreachable!() };
        (ssa, v, vec![five, ten])
    }

    fn inner() -> ssa::Blocks {
        let mut ssa = ssa::Blocks::new(2);
        let uint = IntSize::new(false, 64);

        let params = [(); 2].map(|_| ssa.add_block_param(Block::entry(), MonoType::Int(uint)));

        let n = ssa.copy(Value::Int(8, uint), MonoType::Int(uint));
        let n = ssa.add(n, Value::Int(2, uint), MonoType::Int(uint));

        let [truthy, falsely] = [(); 2].map(|_| ssa.new_block(0));
        ssa.select(n, [(truthy, vec![]), (falsely, vec![])]);

        ssa.switch_to_block(truthy);
        // ssa.copy(Value::Int(0, uint), MonoType::Int(uint));
        ssa.return_(params[1].value());

        ssa.switch_to_block(falsely);
        // ssa.copy(Value::Int(0, uint), MonoType::Int(uint));
        ssa.return_(params[0].value());

        ssa
    }

    #[test]
    fn inlining() -> () {
        let uint = IntSize::new(false, 64);
        let inner = inner();
        let (outer, call, params) = outer(MonoFunc(1));

        let mut outerf = Function::new("outer".into(), outer, MonoType::Int(uint), 1);
        let mut innerf = Function::new("inner".into(), inner, MonoType::Int(uint), 1);

        fn tfmt<'a>(v: &Function) -> MonoFormatter<'a, &Function> {
            let types = Box::leak(Box::new(Map::new()));
            MonoFormatter { types, v }
        }

        // TODO: TODO: It crashes if we don't have any bindings in the block since then there
        // aren't any offsets.
        //
        // We need an unwrap_or or something

        println!(
            "before optimizations:\n{}\n\n{}",
            tfmt(&outerf),
            tfmt(&innerf)
        );

        let types = Types { records: Map::new(), pointer_bits: 0 };
        Optimizer::inline_function(&types, &mut innerf, &mut outerf, Block(1), call, params);

        println!(" --------------------- ");

        println!("after optimizations:\n{}", tfmt(&outerf),);

        panic!("OK");
    }
}
